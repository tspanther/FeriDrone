#ifndef _VL53L0X_PLATFORM_C_
#define _VL53L0X_PLATFORM_C_

#include "vl53l0x_platform.h"
#include "vl53l0x_def.h"
//#include "vl53l0x_platform_log.h"
// #include "vl53l0x_i2c_platform.h"

// #define KEIL_EXTERNAL_ENV

#ifdef __cplusplus
extern "C" {
#endif

/* Simulate functions of Keil environment generated by Cube */

#ifndef I2C_MEMADD_SIZE_8BIT
#define I2C_MEMADD_SIZE_8BIT 0x00000001U
#endif

typedef uint8_t I2C_HandleTypeDef; // note that I2C_HandleTypeDef is a structure not a uint8_t, really
uint8_t hi2c1;

void HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                       uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData,
                       uint16_t Size, uint32_t Timeout);

void HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                      uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData,
                      uint16_t Size, uint32_t Timeout);


/**
 * @defgroup VL53L0X_registerAccess_group PAL Register Access Functions
 * @brief    PAL Register Access Functions
 *  @{
 */

/**
 * Lock comms interface to serialize all commands to a shared I2C interface for
 * a specific device
 * @param   Dev       Device Handle
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_LockSequenceAccess(VL53L0X_DEV Dev) {
  return VL53L0X_ERROR_NONE;
}

/**
 * Unlock comms interface to serialize all commands to a shared I2C interface
 * for a specific device
 * @param   Dev       Device Handle
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_UnlockSequenceAccess(VL53L0X_DEV Dev) {
  return VL53L0X_ERROR_NONE;
}

/**
 * Writes the supplied byte buffer to the device
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   pdata     Pointer to uint8_t buffer containing the data to be
 * written
 * @param   count     Number of bytes in the supplied byte buffer
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_WriteMulti(VL53L0X_DEV Dev, uint8_t index, uint8_t *pdata,
                                 uint32_t count) {
  uint8_t addr = Dev->I2cDevAddr << 1;
  HAL_I2C_Mem_Write(Dev->hi2c, addr, index, I2C_MEMADD_SIZE_8BIT, pdata, count, count);
  return VL53L0X_ERROR_NONE;
}

/**
 * Reads the requested number of bytes from the device
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   pdata     Pointer to the uint8_t buffer to store read data
 * @param   count     Number of uint8_t's to read
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_ReadMulti(VL53L0X_DEV Dev, uint8_t index, uint8_t *pdata,
                                uint32_t count) {
  uint16_t addr = Dev->I2cDevAddr << 1;
  HAL_I2C_Mem_Read(Dev->hi2c, addr, index, I2C_MEMADD_SIZE_8BIT, pdata, count,
                   count);
  return VL53L0X_ERROR_NONE;
}

/**
 * Write single byte register
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   data      8 bit register data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_WrByte(VL53L0X_DEV Dev, uint8_t index, uint8_t data) {
  return VL53L0X_WriteMulti(Dev, index, &data, 1);
}

/**
 * Write word register
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   data      16 bit register data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_WrWord(VL53L0X_DEV Dev, uint8_t index, uint16_t data) {
  return VL53L0X_WriteMulti(Dev, index, (uint8_t *)&data, 2);
}

/**
 * Write double word (4 byte) register
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   data      32 bit register data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_WrDWord(VL53L0X_DEV Dev, uint8_t index, uint32_t data) {
  return VL53L0X_WriteMulti(Dev, index, (uint8_t *)&data, 4);
}

/**
 * Read single byte register
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   data      pointer to 8 bit data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_RdByte(VL53L0X_DEV Dev, uint8_t index, uint8_t *data) {
  return VL53L0X_ReadMulti(Dev, index, data, 1);
}

/**
 * Read word (2byte) register
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   data      pointer to 16 bit data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_RdWord(VL53L0X_DEV Dev, uint8_t index, uint16_t *data) {
  return VL53L0X_ReadMulti(Dev, index, (uint8_t *)data, 2);
}

/**
 * Read dword (4byte) register
 * @param   Dev       Device Handle
 * @param   index     The register index
 * @param   data      pointer to 32 bit data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_RdDWord(VL53L0X_DEV Dev, uint8_t index, uint32_t *data) {
  return VL53L0X_ReadMulti(Dev, index, (uint8_t *)data, 4);
}

/**
 * Threat safe Update (read/modify/write) single byte register
 *
 * Final_reg = (Initial_reg & and_data) |or_data
 *
 * @param   Dev        Device Handle
 * @param   index      The register index
 * @param   AndData    8 bit and data
 * @param   OrData     8 bit or data
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_UpdateByte(VL53L0X_DEV Dev, uint8_t index,
                                 uint8_t AndData, uint8_t OrData) {
  uint8_t data;
  VL53L0X_Error Status = VL53L0X_RdByte(Dev, index, &data);
  if (Status != VL53L0X_ERROR_NONE)
    return Status;

  data = (data & AndData) | OrData;
  return VL53L0X_WrByte(Dev, index, data);
}

/** @} end of VL53L0X_registerAccess_group */

/**
 * @brief execute delay in all polling API call
 *
 * A typical multi-thread or RTOs implementation is to sleep the task for some
 * 5ms (with 100Hz max rate faster polling is not needed) if nothing specific is
 * need you can define it as an empty/void macro
 * @code
 * #define VL53L0X_PollingDelay(...) (void)0
 * @endcode
 * @param Dev       Device Handle
 * @return  VL53L0X_ERROR_NONE        Success
 * @return  "Other error code"    See ::VL53L0X_Error
 */
VL53L0X_Error VL53L0X_PollingDelay(VL53L0X_DEV Dev) {
  /* usually best implemented as a real function */
  HAL_Delay(1);
  return VL53L0X_ERROR_NONE;
}

  /** @} end of VL53L0X_platform_group */

#ifdef __cplusplus
}
#endif

#endif /* _VL53L0X_PLATFORM_C_ */
